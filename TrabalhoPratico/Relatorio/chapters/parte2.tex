\chapter{Motor}
\label{cap:p2}

O \textit{engine} tem como principal função apresentar o modelo gráfico. Para
tal utiliza-se a biblioteca \textit{GLUT (OpenGL Utility Toolkit )}, em conjunto com
a biblioteca gráfica \textit{OpenGL}.


\section{Objectivos}

Com o motor pretende-se uma aplicação que seja capaz de ler um conjunto de pontos especificados em ficheiros XML e .3d e os desenhe numa janela. Além desse objetivo principal foi incluída uma câmara em torno do objeto desenhado e um menu simples que permite alterar o modo de visualização dos pontos.

Nesta secção apresenta-se de que forma o motor foi desenvolvido, começando-se por explicar a leitura dos ficheiros

\section{Leitura Ficheiros}

\subsection{Ficheiro XML}

A estrutura do ficheiro XML contempla apenas dois tipos de elementos:

\begin{itemize}
	\item[\textbf{scene}] - elemento pai
	\item[\textbf{model}] - elemento com 1 atributo \textit{file} cujo valor corresponde ao nome de um ficheiro de pontos
\end{itemize}



O pseudo-codigo da função de leitura do XML pode ser expresso da seguinte forma:

\begin{Verbatim}
vector<const char *> leXML() {
	Abre documento para leitura
	
	if (nao houve erro a abrir o ficheiro) {
		Acede ao primeiro elemento filho de "scene" 
		(que é um elemento "model")
		
		while (houver elementos "model") {
			Vê qual o valor do primeiro atributo 
			do elemento
			
			Coloca o valor do primeiro atributo do
			 elemento no resultado
			 
			Avança para o proximo elemento
		}
	}
	else {
		Informa erro a abrir o ficheiro
	}
	
	Retorna resultado
}
\end{Verbatim}

\subsection{Ficheiros .3d}


Ns ficheiros .3d, cada linha representa um ponto. Em cada linha, existem 3 valores, separados por espaço, correspondentes às coordenadas cartesianas do ponto. É necessário por isso ter uma função que seja capaz de ler os pontos destes ficheiros para que o motor os possa desenhar.

No main está um pedaço de código que permite a leitura destes ficheiros, que recebe como parâmetro o nome de um ficheiro e coloca os pontos do ficheiro num vector de pontos (que é uma variável global). Este vector de pontos será depois o que o motor vai utilizar para desenhar os pontos.

A parte do código que lê o ficheiro XML funciona da seguinte forma:

\begin{Verbatim}

if(xml = fopen(argv[1],"r")) {
lê a primeira linha, verifica abertura do scene
while(consegue ler do xml) {
procura os model files e guarda os nomes 
}
	fclose(xml);

 } else {
 perror(Impossivel abrir XML);}
 
 
\end{Verbatim}

\section{Desenho dos pontos}

O resultado da leitura do XML e dos ficheiros .3d nele especificados é um conjunto de \textit{Ponto3D} que são armazenados numa variável global. Este conjunto de pontos está implementado sobre a forma de um \textit{array<sPonto3D>} que é uma variável global ao programa.

A ordem pela qual os pontos aparecem no vector é a ordem pela qual apareceram nos ficheiros, que por sua vez é a ordem pela qual deverão ser desenhados. Nesta situação, desenhar os pontos corresponde simplesmente a percorrer todos os pontos colocados no vector e a pedir ao GLUT para os desenhar. Mostra-se um excerto de código da função \textit{renderScene()} que corresponde ao desenho dos pontos:

\begin{Verbatim}

glBegin(GL_TRIANGLES);
glColor3f(0.0, 0.0, 1.0);

for(i = 0;i < _buffer_size;i++){
glVertex3f(_buffer_pontos[i].x,_buffer_pontos[i].y,
_buffer_pontos[i].z);
}

glEnd();
\end{Verbatim}

Assume-se que os ficheiros .3d já contêm a ordem correta dos pontos a ser desenhados.

\section{Câmara}

Para se poder ver o objeto desenhado de vários ângulos foi implementada uma câmara.  Visto que a posição da câmara é ------ para gerir o movimento da câmara.


À função \textit{gluLookAt()} são passadas -----

\begin{Verbatim}
gluLookAt(xcam, ycam, zcam,
xcam+lx, ycam+ly,  zcam+lz,
0.0f, 1.0f,  0.0f);
\end{Verbatim}

É possível ao utilizador mudar a posição da câmara. Os controlos são os seguintes:

\begin{itemize}
	\item[\textbf{Tecla 'W'}] permite ao utilizador ir para cima
	\item[\textbf{Tecla 'S'}] permite ao utilizador ir para baixo
	\item[\textbf{Tecla 'A'}] permite ao utilizador ir para a esquerda
	\item[\textbf{Tecla 'D'}] permite ao utilizador ir para a direita
	\item[\textbf{Tecla 'Q'}] permite ao utilizador afastar-se  para cima do objeto
	\item[\textbf{Tecla 'E'}] permite ao utilizador aproximar-se para baixo do objeto
\end{itemize}

Estas operações traduzem-se em operações sobre a câmara disponibilizadas pela classe \textit{CoordsEsfericas}:

\begin{Verbatim}
void processNormalKeys(unsigned char key, int xx, int yy) {

float fraction = 0.1f;

switch (key) {
case 'd' :
angleX += 0.01f;
lx = sin(angleX);
lz = -cos(angleX);
break;

case 'a' :
angleX -= 0.01f;
lx = sin(angleX);
lz = -cos(angleX);
break;

case 'w' :
angleY += 0.01f;
ly = sin(angleY);
break;

case 's' :
angleY -= 0.01f;
ly = sin(angleY);
break;

case 'q' :
ycam = (ycam + 0.5);
break;

case 'e' :
ycam = (ycam - 0.5);
break;
}
glutPostRedisplay();
}


\end{Verbatim}

Quando a função \textit{gluLookAt()} é chamada e acede aos valores de x, y e z da posição da câmara, estes estão atualizados.

\section{Menu}

Para proporcionar alguma flexibilidade na visualização das figuras desenhadas foi incluído um menu que permite ao utilizador alternar entre o modo de visualização de pontos, linhas, ou objeto preenchido:


O menu foi construído da seguinte forma:

\begin{Verbatim}
glutAddMenuEntry("FILL", 0);
glutAddMenuEntry("LINE", 1);
glutAddMenuEntry("POINT", 2);

case 'f' :
_polygon_mode = GL_FILL;
break;
case 'g' :
_polygon_mode = GL_LINE;
break;
case 'h' :
_polygon_mode = GL_POINT;
break;
\end{Verbatim}









